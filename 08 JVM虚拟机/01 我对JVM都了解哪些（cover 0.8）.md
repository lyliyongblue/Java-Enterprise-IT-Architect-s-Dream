### 4、JVM层面对Java提供了哪些技术支持？
- 反射 java.lang.reflect
- ClassLoader
- 初始化class和interface
- 安全相关 java.security
- 多线程
- 弱引用

### 6、Java程序启动时，JMV都在干什么？
1、java *** 启动程序
2、装载配置，根据当前路径和系统版本寻找jvm.cfg
3、根据配置寻找JVM.dll，JVM.dll为JVM主要实现
4、初始化JVM，获得JNIEnv接口。JNIEnv为JVM接口，findClass等操作通过它实现
5、找到main方法并运行

### 7、简述下JMV的基本结构？

### 8、聊下PC寄存器是什么？
PC寄存器
-每个线程拥有一个PC寄存器
-在线程创建时创建
-指向下一 条指令的地址
-执行本地方法时, PC的值为undefined

### 9、聊下JVM的方法区都存储了什么东西？
方法区
- 保存装载的类信息
    类型的常量池
    字段,方法信息
    方法字节码
- 通常和永久区(Perm)关联在一起

JDK6时，String等常量信息置于方法
JDK7时，已经移动到了堆

### 10、聊下对JVM堆的认识？
Java堆
- 和程序开发密切相关
- 应用系统对象都保存在Java堆中
- 所有线程共享Java堆
- 对分代GC来说,堆也是分代的
- GC的主要工作区间

eden | s0 | s1 | tenured
       s0/s1复制区


### 11、聊下对JVM栈的理解？
Java栈
- 线程私有
- 栈由一系列帧组成(因此Java栈也叫做帧栈)
- 帧保存一个方法的局部变量、操作数栈、常量池指针
    Java栈-局部变量表包含参数和局部变量
- 每一次方法调用创建一个帧,并压栈

栈一个槽位32位，long需要2个槽位

### 12、什么是操作数栈？它有什么作用？
Java没有寄存器,所有参数传递使用操作数栈
操作数栈用于对正在操作的数据进行存储
```java
public static int add(int a,int b){
    int c=0;
    c=a+b;
    return C;
}
```
```c++
0: iconst 0// 0压栈
1: istore_ 2 /弹出int ,存放于局部变量2
2: iload 0 // 把局部变量0压栈
3: iload 1 //局部变量1压栈
4: iadd //弹出2个变量 ，求和，结果压栈
5: istore_ 2 //弹出结果,放于局部变量2
6: iload 2 //局部变量2压栈
7: ireturn //返回
```

### 13、什么是栈上分配？
堆上分配，每次需要清理空间
栈上分配，函数调用完成自动清理
小对象(一般几十个bytes) , 在没有被其他线程引用的情况下，可以直接分配在栈上
直接分配在栈上,可以自动回收，减轻GC压力
大对象或者逃逸对象无法栈上分配

### 14、聊下JVM栈、堆、方法区的一个交互流程？



### 15、聊下对线程内存模型理解？线程内存模型在整个虚拟机堆栈模型中处于什么位置？

### 16、Java里面有哪些关键字可以保证可见性？
可见性
- 一个线程修改了变量,其他线程可以立即知道
保证可见性的方法
- volatile
- synchronized ( unlock之前,写变量值回主存)
- final(一旦初始化完成，其他线程就可见)

### 17、聊一下线程执行的有序性和指令重排序的关系？以及线程有序性，指令重排序有哪些优势？
有序性
-在本线程内,操作都是有序的
-在线程外观察 ,操作都是无序的。( 指令重排或主内存同步延时)

指令重排
-线程内串行语义
●写后读    a= 1;b =a;      写一个变量之后,再读这个位置。
●写写      a= 1;a= 2;      写一个变量之后,再写这个变量。
●写写      a= 1;a= 2;      写一个变量之后,再写这个变量。
●以上语句不可重排
●编译器不考虑多线程间的语义
●可重排: a=1;b=2;

指令重排一破坏线程间的有序性

### 18、在指令重排序的基础上，怎么强制保证有序性呢？
通过synchronized等加锁的方式保证线程间的有序性

### 20、聊下JVM什么是解释运行？什么是编译运行？为什么会同时存在两种运行方式？
解释运行
-解释执行以解释方式运行字节码
-解释执行的意思是:读一句执行一句.

编译运行(JIT)
-将字节码编译成机器码
-直接执行机器码
-运行时编译
-编译后性能有数量级的提升

对于C和C++，它们经过一次编译之后，可以由操作系统直接执行，所以它们是编译型语言。
而Java不一样，它首先由编译器编译成.class（字节码）文件，然后在通过JVM从.class文件中读一行解释执行一行，所以它是解释型的语言。
也正是由于java对于多种不同的操作系统有不同的JVM，所以实现了真正意义上的跨平台。

（1）Java语言的编译-->解释-->运行过程
（2）JVM

到这里，大家应该也都明白了。最后给出编译型语言和解释型语言的定义。
定义：
编译型语言：把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。
解释型语言：把做好的源程序翻译一句，然后执行一句，直至结束！
特点：
编译型语言，执行速度快、效率高；依靠编译器、跨平台性差。
解释型语言，执行速度慢、效率低；依靠解释器、跨平台性好。 
举例：
编译型的语言包括：C、C++、Delphi、Pascal、Fortran
解释型的语言包括：Java、Basic、javascript
```sh
https://blog.csdn.net/ns_code/article/details/8877751
```

### 21、GC中，标记压缩对比标记清除而言，有什么优势？
■ -verbose:gc
■ -XX: + printGC
■ -可以打印GC的简要信息
[GC 4790K-> 374K(15872K);0.0001606 secs]
[GC 4790K-> 374K(15872K), 0.0001474 secs]

■ -XX:+ PrintGCDetails
打印GC详细信息
■ -XX:+ PrintGCTimeStamps
 -打印CG发生的时间戳
■ 例
```sh
[GC[DefNew: 4416K- > 0K(4928K), 0.0001897 secs] 4790K- > 374K(15872K), 0.0002232 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
```
##### 标记-清除算法
标记-清除算法是现代垃圾回收算法的思想基础。
标记清除算法将垃圾回收分为两个阶段:标记阶段和清除阶段。
一种可行的实现是,在标记阶段，首先通过根节点,标记所有从根节点开始的可达对象。因此,未被标记的对象就是未被引用的垃圾对象。然后,在清除阶段,清除所有未被标记的对象。
##### 标记-压缩算法
标记-压缩算法适合用于存活对象较多的场合,如老年代。它在标记清除算法的基础上做了一些优化。
和标记-清除算法一样,标记-压缩算法也首先需要从根节点开始,对所有可达对象做一次标记，
但之后,它并不简单的清理未标记的对象,而是将所有的存活对象压缩到内存的一端之后,清理边界外所有的空间。

##### 复制算法
■与标记-清除算法相比,复制算法是一种相对高效的回收方法
■不适用于存活对象较多的场合如老年代
■将原有的内存空间分为两块,每次只使用其中一块,在垃圾回收时,将正在使用的内存中的存活
对象复制到未使用的内存块中，之后,清除正在使用的内存块中的所有对象,交换两个内存的角色,完成垃圾回收
■复制算法的最大问题是:空间浪费整合标记清理思想

分代思想
■依据对象的存活周期进行分类,短命对象归为新生代,长命对象归为老年代。
■根据不同代的特点 ,选取合适的收集算法
- 少量对象存活,适合复制算法
- 大量对象存活,适合标记清理或者标记压缩


### 22、聊一下Java中的GC过程？

### 23、Java的GC都使用了哪些回收算法？各种算法作用在什么场景下？
- 应用计数算法 （Java未使用）
- 标记-清除算法 （老年代）
- 标记-压缩（老年代）
- 复制算法 （新生代）




### 24、聊一下GC中的可触及性？以及针对可触及性有哪些建议？
■可触及的
- 从根节点可以触及到这个对象
■可复活的
- 一旦所有引用被释放,就是可复活状态
- 因为在finalize0中可能复活该对象
■不可触及的 
- 在finalize()后,可能会进入不可触及状态
- 不可触及的对象不可能复活
- 可以回收
■经验: 避免使用finalize() ,操作不慎可能导致错误。
■优先级低 ,何时被调用，不确定
- 何时发生GC不确定
■可以使用try-catch-finally来替代它

### 25、GC中什么对象才叫根对象？
- 栈中引用的对象
- 方法区中静态成员或者常量引用的对象(全局对象)
- JNI方法栈中引用对象

### 26、Stop-The-World是什么？为什么会发生Stop-The-World呢？Stop-The-World有什么危害？
- Java中一 种全局暂停的现象
- 全局停顿 ,所有Java代码停止, native代码可以执行,但不能和JVM交互
- 多半由于GC引起
    ●Dump线程
    ●死锁检查
    ●堆Dump

■GC时为什么会有全局停顿 ?
- 类比在聚会时打扫房间 ,聚会时很乱，又有新的垃圾产生,房间永远打扫不干净,只有让大家停止活动了,才能将房间打扫干净。
■危害
- 长时间服务停止,没有响应
- 遇到HA系统，可能引起主备切换，严重危害生产环境。

### 27、什么是串行回收器？它的优劣特点是什么？如何启用串行收集器？
■最古老, 最稳定
■效率高
■可能会产生较长的停顿
■-XX:+ UseSerialGC
- 新生代、老年代使用串行回收
- 新生代复制算法
- 老年代标记-压缩


### 28、什么是并行回收器（ParNew）？如何启用并行回收器？
■ParNew
- -XX:+ UseParNewGC
    ●新生代并行
    ●老年代串行
- Serial收集器新生代的并行版本
- 复制算法
- 多线程，需要多核支持
- -XX:ParallelGCThreads 限制线程数量

■Parallel收集器
- 类似ParNew
- 新生代复制算法
- 老年代标记-压缩
- 更加关注吞吐量
- -XX:+ UseParallelGC
    ●使用Parallel收集器 +老年代串行
- -XX:+UseParallelOldGC
    ●使用Parallel收集器+并行老年代

■-XX:MaxGCPauseMills
- 最大停顿时间,单位毫秒
- GC尽力保证回收时间不超过设定值
■-XX:GCTimeRatio
- 0-100的取值范围
- 垃圾收集时间占总时间的比
- 默认99 ,即最大允许1%时间做GC
这两个参数是矛盾的。因为停顿时间和吞吐量不可能同时调优


### 29、什么是并行回收器（Parallel）？如何开启该并行回收器？

### 30、GC回收器怎么优化配置？

### 31、什么是CMS收集器？怎么开启？为什么会产生垃圾碎片？
能与应用程序一起执行，停顿减小了，系统吞吐量会降低，老年代收集器
关注吞吐量
■CMS收集器
- Concurent Mark Sweep并发标记清除
- 标记-清除算法
- 与标记-压缩相比
- 并发阶段会降低吞吐量
- 老年代收集器 (新生代使用ParNew )
- -XX:+UseConcMarkSweepGC

■CMS运行过程比较复杂 ,着重实现了标记的过程,可分为
- 初始标记
    ●根可以直接关联到的对象
    ●速度快
- 并发标记(和用户线程一起)
    ●主要标记过程,标记全部对象
-重新标记
    ●由于并发标记时 ,用户线程依然运行.因此在正式清理前,再做修正
-并发清除(和用户线程一起)
    ●基于标记结果，直接清理对象

■特点
- 尽可能降低停顿
- 会影响系统整体吞吐量和性能
    ●比如,在用户线程运行过程中,分一半CPU去做GC ,系统性能在GC阶段,反应速度就下降一半
- 清理不彻底
    ●因为在清理阶段,用户线程还在运行,会产生新的垃圾,无法清理
- 因为和用户线程一 起运行 ,不能在空间快满时再清理
    ●-XX:CMSInitiatingOccupancyFraction设置触发GC的阈值
    ●如果不幸内存预留空间不够,就会引起concurrent mode failure

### 32、如何减轻GC的压力呢？

### 33、配合GC参数配置，怎么调配一个高吞吐量的Tomcat？

### 34、ClassLoader加载字节码时，会先进行字节码校验，字节码校验都做了什么操作呢？
■装载类的第一个阶段
■取得类的_ -进制流
■转为方法区数据结构
■在Java堆中生 成对应的java.lang.Class对象

链接 - 验证
- 目的: 保证Class流的格式是正确的
    ●文件格式的验证
        - 是否I以0xCAFEBABE开头
        - 版本号是否合理
    ●元数据验证
        - 是否有父类
        - 继承了final类 ?
        - 非抽象类实现了所有的抽象方法
    ●字节码验证(很复杂)
        - 运行检查
        - 栈数据类型和操作码数据参数吻合
        - 跳转指令指定到合理的位置
    ●符号引用验证
        - 常量池中描述类是否存在
        - 访问的方法或字段是否存在且有 足够的权限

■链接->准备
    - 分配内存 ,并为类设置初始值( 方法区中)
        ●public static int v=1;
        ●在准备阶段中, v会被设置为0
        ●在初始化的< clinit>中才会被设置为1
        ●对于static final类型,在准备阶段就会被赋上正确的值
        ●public static final intv=1;

■链接->解析
    - 符号引用替换为直接引用

### 35、java.lang.NoSuchFieldError错误可能在什么阶段抛出？

### 36、什么是类装载器ClassLoader？
■ ClassLoader是一 个抽象类
■ ClassLoader的实例将读 入Java字节码将类装载到JVM中
■ ClassLoader可以定制 ,满足不同的字节码流获取方式
■ ClassLoader负责类装载过程中的加载阶段

### 37、常见的ClassLoader都有哪些？
■BootStrap ClassLoader ( 启动ClassLoader )
■Extension ClassLoader ( 扩展ClassLoader )
■App ClassLoader ( 应用ClassLoader/系统ClassLoader )
■Custom ClassLoader(自定义ClassLoader)

■每个ClassLoader都有一个Parent作为父亲

1、自下向上检查是否已经加载
2、自上向下加载Class

双亲模式的问题:
顶层ClassLoader，无法加载底层ClassLoader的类

### 38、能否只用反射，将类注入启动ClassLoader呢？

### 39、如何去破坏JVM默认的ClassLoader双亲模式加载？
■双亲模式的破坏
- 双亲模式是默认的模式,但不是必须这么做
- Tomcat的WebappClassLoader 就会先加载自己的Class ,找不到再委托parent
- OSGi的ClassLoader形成网状结构,根据需要自由加载Class

### 40、如何自定义类加载器，并实现应用的类让启动类加载器加载？

### 41、使用ClassLoader实现热替换Class？
■含义:
一当一个class被替换后 ,系统无需重启,替换的类立即生效
-例子:
●geym.jyvm.ch6.hot.CVersionA
```java
public class CVersionA {
    public void sayHello0 {
        System.out.printin("hello world! (version A)");
    }
}
```
■替换后，DoopRun 的输出变为
```sh
hello world! (version B)
```

### 42、怎么查看Java程序相关指标，确认Java程序的监控健康，运行状态，问题分析？
■top
    - 可以知道哪个程序占CPU量多

■vmstat
    - 可以统计系统的CPU， 内存。swap, io等情况
    - CPU占用率很高，上下文切换频繁，说明系统有线程正在频繁切换

■pidstat
- 细致观察进程
- 需要安装
```sh
sudo apt get install systat
```
- 监控CPU
- 监控IO
- 监控内存

■jps
- 列出java进程 。类似于ps命令
- 参数-q可以指定jps只输出进程ID 。 不输出类的短名称
- 参数-m可以用于输出传递给Java进程(主函数)的参数
- 参数-l可以用于输出主函数的完整路径
- 参数一v可以显示传递给JVM的参数

■jinfo
```sh
- 可以用来 查看正在运行的Java应用程序的扩展参数，甚至支持在运行时，修改部分参数
- -flag <name> :打印指定VM的参数值
- -lag [+H-]<name> :设置指定VM参数的布尔值
- -liag <name >= <value> :设置指定VM参数的值
```

■jmap
- 生成Java应用程序的堆快照和对象的统计信息
```sh
jmap histo 2972 >cls bxt
```

■Dump堆
```sh
jmap -dump:format= b,file= c\heap.hprof 2972
```

■jstack
- 打印线程dump
- -l打印锁信息
- -m 打印java和Onative的帧信息
- -F 强制dump，当jstack没有响应时使用
```sh
jstack 120 >>C.a.txt
```

### 43、用过哪些图形界面的Java检查工具？
JConsole
- 图形化监控工具
- 可以查看Java应用程序的运行概况。监控堆信息、永久区使用情况、类加载情况等

Visual VM
- Visual VM是一个功能强大的多合一故局诊断和性能监控的可视化工具
- 性能监控，找到占用CPU时间长的方法
- 分析堆Dump

### Java什么是浅堆，什么是深堆？

### 44、什么是MAT，MAT都可以做什么？

### 45、对象头Mark是什么？有什么用？
■Mark Word ,对象头的标记, 32位
■描述对象的hash.锁信息,垃圾回收标记,年龄
- 指向锁记录的指针
- 指向monitor的指针
- GC标记
- 偏向锁线程ID

### 46、偏向锁是什么？
■大部分情况是没有竞争的 ,所以可以通过偏向来提高性能
■所谓的偏向 ,就是偏心,即锁会偏向于当前已经占有锁的线程
■将对象头Mark的标记设置为偏向,并将线程ID写入对象头Mark
■只要没有竞争,获得偏向锁的线程,在将来进入同步块,不需要做同步
■当其他线程请求相同的锁时 ,偏向模式结束
■-XX:+ UseBiasedLocking
    - 默认启用
■在竞争激烈的场合 ,偏向锁会增加系统负担

### java中轻量级锁是什么？
■如果轻量级锁失败 ,表示存在竞争,升级为重量级锁(常规锁)
■在没有锁竞争的前提下 ,减少传统锁使用OS互斥量产生的性能损耗
■在竞争激烈时 ,轻量级锁会多做很多额外操作,导致性能下降

### 什么是自旋锁？
■当竞争存在时 ,如果线程可以很快获得锁,那么可以不在OS层挂起线程,让线程做几个空操作(自旋)
■JDK1.6中-XX: + UseSpinning开启
■JDK1.7中,去掉此参数,改为内置实现
■如果同步块很长,自旋失败,会降低系统性能
■如果同步块很短，自旋成功,节省线程挂起切换时间,提升系统性能

### 偏向锁,轻量级锁，自旋锁总结
■不是Java语言层面的锁优化方法
■内置于JVM中的获取锁的优化方法和获取锁的步骤
- 偏向锁可用会先尝试偏向锁
- 轻量级锁可用会先尝试轻量级锁
- 以上都失败,尝试自旋锁
- 再失败,尝试普通锁,使用OS互斥量在操作系统层挂起

### 47、ASM是什么？接触过哪些工具、框架使用了ASM？
- Java字节码操作框架
- 可以用于修改现有类或者动态产生新类
- 用户
- AspectJ
- Clojure
- Ecplise
- spring
- cglib
- hibernate

■模拟实现AOP字节码织入
- 在函数开始部分或者结束部分嵌入
- 可用于进行鉴权、日志等

### 48、JIT是什么？JIT有什么用？
■字节码执行性能较差，所以可以对于热点代码编译成机器码再执行，在运行时的编译，叫做JTT Just-In-Time
■J打T的基本思路是，将热点代码，就是执行比较频繁的代码，编译成机器码。

当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为"Hot Spot Code"（热点代码)，为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码


调用的方法，被多次调用的循环体。
方法调用计数器:方法调用次数、回边计数器、方法内循环次数达到一定量后就会开启JIT
